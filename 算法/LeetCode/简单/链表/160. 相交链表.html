<!--
 * @Author: liwz
 * @Date: 2025-03-05 13:50:23
 * @LastEditors: liwz
 * @LastEditTime: 2025-03-05 13:57:27
 * @FilePath: /study_new/算法/LeetCode/简单/链表/160. 相交链表.html
 * @Description:
 *
 * Copyright (c) 2025 by ${git_name_email}, All Rights Reserved.
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
    给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
      图示两个链表在节点 c1 开始相交：

      题目数据 保证 整个链式结构中不存在环。
      注意，函数返回结果后，链表必须 保持其原始结构 。
      自定义评测：
      评测系统 的输入如下（你设计的程序 不适用 此输入）：
      - intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
      - listA - 第一个链表
      - listB - 第二个链表
      - skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
      - skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
      评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

    */
      /**
       * Definition for singly-linked list.
       * function ListNode(val) {
       *     this.val = val;
       *     this.next = null;
       * }
       */

      function ListNode(val) {
        this.val = val
        this.next = null
      }

      /**
       * @param {ListNode} headA
       * @param {ListNode} headB
       * @return {ListNode}
       */
      var getIntersectionNode = function (headA, headB) {
        if (!headA || !headB) return null
        let p1 = headA
        let p2 = headB
        while (p1 !== p2) {
          // p1走一步，如果走到A 链表末尾，转到B 链表头
          if (p1 === null) p1 = headB
          else p1 = p1.next
          // p2走一步，如果走到B 链表末尾，转到A 链表头
          if (p2 === null) p2 = headA
          else p2 = p2.next
        }
        return p1
      }
      console.log(getIntersectionNode([4, 1, 8, 4, 5], [5, 6, 1, 8, 4, 5]))
    </script>
  </body>
</html>
